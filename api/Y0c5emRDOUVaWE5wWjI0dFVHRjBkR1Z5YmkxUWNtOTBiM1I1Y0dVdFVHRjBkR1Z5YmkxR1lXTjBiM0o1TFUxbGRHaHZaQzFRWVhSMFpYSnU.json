{"title":"Design Pattern - Prototype Pattern && Factory Method Pattern","date":"2018-05-11T02:16:47.000Z","excerpt":"","slug":"Design-Pattern-Prototype-Pattern-Factory-Method-Pattern","comments":true,"tags":["Design Pattern"],"updated":"2018-05-12T07:19:41.000Z","content":"<h1 id=\"Prototype-Pattern\"><a href=\"#Prototype-Pattern\" class=\"headerlink\" title=\"Prototype Pattern\"></a>Prototype Pattern</h1><h2 id=\"Intro\"><a href=\"#Intro\" class=\"headerlink\" title=\"Intro\"></a>Intro</h2><blockquote>\n<p>使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象</p>\n</blockquote>\n<p><strong>原型模式</strong>(<a href=\"https://en.wikipedia.org/wiki/Prototype_pattern\" target=\"_blank\" rel=\"noopener\">Prototype Pattern</a>)是创建型模式的一种。通过复制一个已经存在的实例来返回新的实例，而不是新建实例。被复制的实例就是<code>原型</code>。</p>\n<p><img src=\"https://github.com/changwensir/study_document/raw/master/upload_img/pattern/Prototype.jpeg/\" alt=\"UML图\"></p>\n<p>​        这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。<code>Prototype</code>是原型类，<code>ConcretePrototype</code>是子类，<code>Client</code>是调用类。</p>\n<h2 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h2><p>Prototype类需要具备两个条件</p>\n<ul>\n<li><p>实现Cloneable接口</p>\n<p>在Java中的Cloneable接口的作用只有一个：在运行时通知虚拟机可以安全地在实现了此接口的类上使用clone方法。</p>\n<p>通过该方法进行对象的拷贝，Java提供了一个Cloneable接口来<strong>标示</strong>这个对象是可拷贝的。Cloneable里面一个方法都没有的，这个接口只是一个标记作用，在JVM中具有这个标记的对象有可能被拷贝。</p>\n<p>在JVM中，只有实现了这个接口的类才可以被拷贝，否则会抛出<code>CloneNotSupportedException</code>异常。</p>\n</li>\n<li><p>重写Object类中的clone方法</p>\n<p>Java中所有类的父类是Object类，Object有个clone方法，作用是返回对象的一个拷贝，但是其作用于是protected的，一般类无法调用，因此Prototype类需要将clone方法的作用于修改为public</p>\n</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1682758-3ed57f23184d809d.png?imageMogr2/auto-orient/\" alt=\"浅拷贝和深拷贝\"></p>\n<p><strong>浅拷贝</strong>：clone只是拷贝本对象，其对象内部的数组、引用对象、引用类型都不拷贝，还是指向原型的内部地址。<strong>两个对象的地址是一样的</strong>。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Prototype</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"keyword\">clone</span>() <span class=\"keyword\">throw</span> CloneNotSupportedException&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> super.<span class=\"keyword\">clone</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcretePrototype1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Prototype</span></span>&#123;</span><br><span class=\"line\">    public <span class=\"type\">Object</span> clone() <span class=\"keyword\">throw</span> <span class=\"type\">CloneNotSupportedException</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"type\">ConcretePrototype1</span>) <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcretePrototype2</span> <span class=\"keyword\">extends</span> <span class=\"title\">Prototype</span></span>&#123;</span><br><span class=\"line\">    public <span class=\"type\">Object</span> clone() <span class=\"keyword\">throw</span> <span class=\"type\">CloneNotSupportedException</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"type\">ConcretePrototype2</span>) <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>深拷贝</strong>：将对象复制后，基本数据类型学和引用类型都重新创建。<strong>两个对象的地址不一样</strong>。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public<span class=\"built_in\"> interface </span>Prototype&#123;</span><br><span class=\"line\">    public Object clone();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcretePrototype1</span> <span class=\"keyword\">implements</span> <span class=\"title\">Prototype</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Prototype prototype = <span class=\"keyword\">new</span> ConcretePrototype1();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> prototype;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcretePrototype2</span> <span class=\"keyword\">implements</span> <span class=\"title\">Prototype</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Prototype prototype = <span class=\"keyword\">new</span> ConcretePrototype2();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> prototype;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用原型的客户端</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Client&#123;</span><br><span class=\"line\">    private Prototype type;</span><br><span class=\"line\">    public Client(Prototype type)&#123;</span><br><span class=\"line\">        this.type = type;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public void operation()&#123;</span><br><span class=\"line\">        Prototype newPrototype = type.clone();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果一个对象中只有基本类型属性，那深拷贝和浅拷贝效果都是一样的，基本类型数据不管是用深还是浅都会被拷贝出一份，但如果对象中包含引用对象属性，那浅拷贝其实这是拷贝了一份引用，而深拷贝确实把整个引用对象都拷贝了一份。</p>\n<h2 id=\"Attention\"><a href=\"#Attention\" class=\"headerlink\" title=\"Attention\"></a>Attention</h2><p><strong>Advantages</strong></p>\n<ol>\n<li>性能优良 原型模式是在内存二进制流的拷贝，比直接new一个对象性能要好很多</li>\n<li>构造函数不会执行 因为对象的复制是通过调用Object类的clone方法来完成的，直接在内存中复制数据 因此不用调用到类的构造方法</li>\n<li>根据客户端要求实现动态创建对象，客户端不需要知道对象的创建细节，便于代码的维护和拓展。</li>\n</ol>\n<p><strong>Usage Scenario</strong></p>\n<ul>\n<li>资源优化：类初始化需要消化非常多的资源(包括数据、硬件资源等) 通过原型拷贝避免消耗</li>\n<li>通过new 产生的一个对象需要非常繁琐的数据准备或者权限</li>\n<li>一个对象多个修改者 ：一个对象需要提供给其他对象访问，而且各个调用者都需要修改其值 （保护性拷贝）</li>\n</ul>\n<p><strong>final关键字</strong></p>\n<p>final类型是不能重新赋值的，所以要使用clone() 类的成员变量上不要加final关键字</p>\n<p>在实际项目中，原型模式一般是和工厂方法模式同时出现 通过clone方法创建一个对象，然后由工厂方法提供给调用者。</p>\n<h1 id=\"Factory-Method-Pattern\"><a href=\"#Factory-Method-Pattern\" class=\"headerlink\" title=\"Factory Method Pattern\"></a>Factory Method Pattern</h1><h2 id=\"Intro-1\"><a href=\"#Intro-1\" class=\"headerlink\" title=\"Intro\"></a>Intro</h2><blockquote>\n<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类</p>\n</blockquote>\n<p>工厂模式有三种：简单工厂模式 工厂方法模式 抽象工厂模式 这里讲的是第二种</p>\n<p><strong>工厂方法</strong>(<a href=\"https://en.wikipedia.org/wiki/Factory_method_pattern\" target=\"_blank\" rel=\"noopener\">Factory method pattern</a>)使一个类的实例延迟到其子类。封装类中不变的部分，提取其中个性化善变的部分为独立类。</p>\n<p>创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>\n<p>在工厂方法模式中，抽象产品类Product负责定义产品的共性，实现对事物最抽象的定义；Creator为抽象创建类，具体如何创建产品类是由具体的实现工厂ConcreteProduct完成的。</p>\n<p><img src=\"https://github.com/changwensir/study_document/raw/master/upload_img/pattern/FactoryMethod.jpeg\" alt=\"UMI\"></p>\n<h2 id=\"Example-1\"><a href=\"#Example-1\" class=\"headerlink\" title=\"Example\"></a>Example</h2><p><strong>抽象产品类</strong>：具体产品继承的父类或者实现的接口</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title\">Product</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">method2</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>具体产品类</strong>：具体工厂角色所创建的对象就是该角色的实例</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteProduct</span> <span class=\"keyword\">extends</span> <span class=\"title\">Product</span> </span>&#123;</span><br><span class=\"line\">   public void method2()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>抽象工厂类</strong>：工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的<strong>接口</strong>或者必须<strong>继承</strong>的父类。</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> Creator &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> &lt;T <span class=\"keyword\">extends</span> <span class=\"built_in\">Product</span>&gt; T createProduct(<span class=\"keyword\">Class</span>&lt;T&gt; c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>具体工厂类</strong>：与具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。负责每个产品。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteCreator</span> <span class=\"keyword\">extends</span> <span class=\"title\">Creator</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public &lt;<span class=\"type\">T</span> <span class=\"keyword\">extends</span> <span class=\"type\">Product</span>&gt; <span class=\"type\">T</span> createProduct(<span class=\"type\">Class</span>&lt;<span class=\"type\">T</span>&gt; c)&#123;</span><br><span class=\"line\">        <span class=\"type\">Product</span> product = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            product = (<span class=\"type\">Product</span>) <span class=\"type\">Class</span>.forName(c.getName()).newInstance();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (<span class=\"type\">Exception</span> e)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"type\">T</span>) product;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>场景类</strong></p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class<span class=\"built_in\"> Client </span>&#123;</span><br><span class=\"line\">    public static void main(String [] args)&#123;</span><br><span class=\"line\">        Creator creator = new ConcreteCreator();</span><br><span class=\"line\">        Product product = creator.createProduct(ConcreteProduct.class);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>一个抽象产品类，可以派生出多个具体产品类。</li>\n<li>一个抽象工厂类，可以派生出多个具体工厂类。</li>\n<li>每个具体工厂类，只能创建一个具体产品类的实例。</li>\n</ul>\n<p>当有新的产品产生时，只要创建并继承抽象产品 而不用修改任何一个类。比如说抽象产品是tp，具体产品类是tpT470、tpE470 当新产品T480出现时，只需要继承tp这个类，然后定义新的工厂，同样是实现工厂接口，生产具体的产品。</p>\n<p>符合开闭原则。对拓展开放；对修改封闭。</p>\n<h2 id=\"Attention-1\"><a href=\"#Attention-1\" class=\"headerlink\" title=\"Attention\"></a>Attention</h2><p><strong>使用场景</strong></p>\n<ul>\n<li>日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。</li>\n<li>数据库访问：当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。</li>\n<li>设计一个连接服务器的框架，需要三个协议 “POP3” “IMAP” “HTTP” 可以把这三个作为产品类，共同实现一个接口</li>\n</ul>\n<p><strong>优点</strong></p>\n<ul>\n<li>良好的封装性，代码结构清晰  　　</li>\n<li>良好的拓展性，在增加产品类的情况下，只要适当地修改具体或扩展工厂类即可</li>\n<li>屏蔽产品类。调用者只需要关心产品的接口。如果从数据Mysql切换到Oracle，只要切换驱动名称就行。</li>\n<li>典型的解耦框架。高层模块值需要知道产品的抽象类，其他的实现类都不用关心，符合迪米特法则，我们不需要的就是不要去交流；也符合依赖倒置原则，只依赖产品类的抽象；也符合里氏替换原则，使用产品子类替换产品父类。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>每增加一个产品都需要增加一个具体类和对象实现工厂，使系统中类的个数成倍增加。当产品种类非常多的时候会出现大量的与之对应的工厂对象。在一定程度上增加了系统的复杂度，也增加了系统具体类的依赖。</li>\n</ul>\n<p><strong>参考链接：</strong></p>\n<ul>\n<li><a href=\"https://blog.csdn.net/ochangwen/article/details/73385595\" target=\"_blank\" rel=\"noopener\">23种设计模式—-创建型模式（工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式)</a></li>\n<li><a href=\"https://www.jianshu.com/p/4e1f2d090f20\" target=\"_blank\" rel=\"noopener\">java中的原型模式</a></li>\n</ul>\n<p><strong>拓展阅读：</strong></p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/f6e419b92809\" target=\"_blank\" rel=\"noopener\">创建型开发模式-简单工厂模式、工厂模式、抽象工厂模式</a></li>\n</ul>\n","prev":{"title":"JavaBaseNote","slug":"JavaBaseNotes"},"next":{"title":"Annotation","slug":"Annotation"},"link":"http://yoursite.com/post/Design-Pattern-Prototype-Pattern-Factory-Method-Pattern"}