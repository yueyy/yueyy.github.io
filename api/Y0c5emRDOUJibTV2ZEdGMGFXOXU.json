{"title":"Annotation","date":"2018-05-03T03:34:50.000Z","excerpt":"","slug":"Annotation","comments":true,"updated":"2018-05-03T12:16:17.000Z","content":"<p>[TOC]</p>\n<h1 id=\"Java-Annotation\"><a href=\"#Java-Annotation\" class=\"headerlink\" title=\"Java Annotation\"></a>Java Annotation</h1><h2 id=\"What-is-annotation\"><a href=\"#What-is-annotation\" class=\"headerlink\" title=\"What is annotation\"></a>What is annotation</h2><blockquote>\n<p><em>Annotations</em>, a form of metadata, provide data about a program that is not part of the program itself. Annotations have no direct effect on the operation of the code they annotate.</p>\n</blockquote>\n<p>​       注解（<a href=\"https://docs.oracle.com/javase/tutorial/java/annotations/\" target=\"_blank\" rel=\"noopener\">Annotation</a>）是java1.5开始引入的一种注释机制。很多有名的框架都大量使用注解。Java注解用于为Java代码提供元数据，可被编译工具解析，不直接影响代码执行。</p>\n<p>​        Annontation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。</p>\n<h2 id=\"Architecture\"><a href=\"#Architecture\" class=\"headerlink\" title=\"Architecture\"></a>Architecture</h2><p><img src=\"https://images0.cnblogs.com/blog/497634/201309/28123151-d471f82eb2bc4812b46cc5ff3e9e6b82.jpg\" alt=\"image\"></p>\n<ul>\n<li>每个Annotation对象都有唯一的RetentionPolicy属性</li>\n<li>每个Annotation对象可以有若干ElementType属性</li>\n<li>Annotation有许多实现类</li>\n</ul>\n<h2 id=\"Grammer\"><a href=\"#Grammer\" class=\"headerlink\" title=\"Grammer\"></a>Grammer</h2><p>注解通过<code>@interface</code>关键字进行定义</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public @interface TestAnnotation&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@TestAnnotation</span><br><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以理解为将自定义好的<code>@TestAnnotation</code>标签贴到<code>Test</code>类上</p>\n<p>但是注解要正常工作 还需要<strong>元注解</strong></p>\n<h2 id=\"Meta-Annotation\"><a href=\"#Meta-Annotation\" class=\"headerlink\" title=\"Meta Annotation\"></a>Meta Annotation</h2><p>元注解是可以注解到注解上的注解。它是一种基本注解，但它能够应用到其他注解上。</p>\n<p>Annotation Type</p>\n<table>\n<thead>\n<tr>\n<th>注解类型</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>@Documented</td>\n<td>能够将注解中的元素包含到 Javadoc 中</td>\n</tr>\n<tr>\n<td>@Retention</td>\n<td>解释说明了这个注解的的存活时间</td>\n</tr>\n<tr>\n<td>@Target</td>\n<td>限定了注解运用场景</td>\n</tr>\n<tr>\n<td>@Inherited</td>\n<td>表示注解类型能被自动继承</td>\n</tr>\n<tr>\n<td>@Repeatable</td>\n<td>表示可重复</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Documented\"><a href=\"#Documented\" class=\"headerlink\" title=\"@Documented\"></a>@Documented</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Documented</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class=\"line\">public @interface Documented &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>@Documented</strong>表示拥有该注解的元素可通过javadoc此类的工具进行文档化。</p>\n<p>该类型应用于注解那些影响客户使用带注释(comment)的元素声明的类型。如果类型声明是用Documented来注解的，这种类型的注解被作为被标注的程序成员的公共API。</p>\n<p>例如，上面源码<code>@Retention</code>的定义中有一行<code>@Documented</code>，意思是指当前注解的元素会被javadoc工具进行文档化，那么在查看Java API文档时可查看当该注解元素。</p>\n<h3 id=\"Retention\"><a href=\"#Retention\" class=\"headerlink\" title=\"@Retention\"></a>@Retention</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Documented</span><br><span class=\"line\">@Retention((RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class=\"line\">public @interface Retention &#123;</span><br><span class=\"line\">    RetentionPolicy value();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>RetentionPolicy</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SOURCE</td>\n<td>注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视</td>\n</tr>\n<tr>\n<td>CLASS</td>\n<td>注解只被保留到编译进行的时候，它并不会被加载到 JVM 中（Default）</td>\n</tr>\n<tr>\n<td>RUNTIME</td>\n<td>注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们</td>\n</tr>\n</tbody>\n</table>\n<p><strong>@Retention</strong>相当于一个时间戳 指明了标签张贴的时间周期。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Retention(RetentionPolicy。RUNTIME)</span><br><span class=\"line\">public @interface TestAnnotation&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Target\"><a href=\"#Target\" class=\"headerlink\" title=\"@Target\"></a>@Target</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Documented</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class=\"line\">public @interface Target &#123;</span><br><span class=\"line\">    ElementType[] value();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>@Target</strong>指定了注解运用的地方，限定了运用的场景</p>\n<table>\n<thead>\n<tr>\n<th>ElementType</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TYPE</td>\n<td>类、接口（包括注解类型）或enum声明</td>\n</tr>\n<tr>\n<td>FIELD</td>\n<td>字段（域）声明，包括enum实例</td>\n</tr>\n<tr>\n<td>METHOD</td>\n<td>方法声明</td>\n</tr>\n<tr>\n<td>PARAMETER</td>\n<td>参数声明</td>\n</tr>\n<tr>\n<td>CONSTRUCTOR</td>\n<td>构造方法声明</td>\n</tr>\n<tr>\n<td>LOCAL_VARIABLE</td>\n<td>局部变量声明</td>\n</tr>\n<tr>\n<td>ANNOTATION_TYPE</td>\n<td>注解声明（用于另一个注解上）</td>\n</tr>\n<tr>\n<td>PACKAGE</td>\n<td>包声明</td>\n</tr>\n<tr>\n<td>TYPE_PARAMETER</td>\n<td>类型参数声明(since 1.8)</td>\n</tr>\n<tr>\n<td>TYPE_USE</td>\n<td>类型使用声明(since 1.8)</td>\n</tr>\n</tbody>\n</table>\n<p>若没有<code>@Target</code>元注解则默认可以适用所有的程序元素。</p>\n<p>多个值使用需加上<code>{}</code>并用<code>,</code>隔开</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>Type Annotation</strong> </p>\n<p>TYPE_PARAMETER TYPE_USE</p>\n<p>(since Java8)</p>\n<p>以前的注解只能用在包、类、构造器、方法、成员变量、参数、局部变量。如果想在创建对象、类型转换、使用implements实现接口、使用throw声明抛出异常时使用则不行。</p>\n<p><strong>Example</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(ElementType.TYPE_USE)</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@Documented</span><br><span class=\"line\">public @interface NotNull &#123;</span><br><span class=\"line\">    String value() default &quot;&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//implements实现接口中使用Type Annotation</span><br><span class=\"line\">public class Test implements @NotNull(value=&quot;Serializable&quot;) Serializable&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        //泛型中使用Type Annotation  、   抛出异常中使用Type Annotation</span><br><span class=\"line\">    public  void foo(List&lt;@NotNull String&gt; list) throws @NotNull(value=&quot;ClassNotFoundException&quot;) ClassNotFoundException &#123;</span><br><span class=\"line\">        //创建对象中使用Type Annotation</span><br><span class=\"line\">        Object obj =new @NotNull String(&quot;annotation.Test&quot;);</span><br><span class=\"line\">        //强制类型转换中使用Type Annotation</span><br><span class=\"line\">        String str = (@NotNull String) obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Inherited\"><a href=\"#Inherited\" class=\"headerlink\" title=\"@Inherited\"></a>@Inherited</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Documented</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class=\"line\">public @interface Inherited &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>@Inherited</strong>表示该注解类型被自动继承。</p>\n<p>如果用户在当前类中查询这个元注解类型并且当前类的声明中不包含这个元注解类型，那么也将自动查询当前类的父类是否存在Inherited元注解，这个动作将被重复执行知道这个标注类型被找到，或者是查询到顶层的父类。</p>\n<p>也就是说，如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Inherited</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@interface Test &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@Test</span><br><span class=\"line\">public class A &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">public class B extends A &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>注解<code>@Test</code>被<code>@Inherited</code>修饰，类<code>A</code>被<code>@Test</code>修饰，类<code>B</code>继承自<code>A</code> ，于是类<code>B</code>也拥有<code>@Test</code>注解。</p>\n<h3 id=\"Repeatable\"><a href=\"#Repeatable\" class=\"headerlink\" title=\"@Repeatable\"></a>@Repeatable</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Documented</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class=\"line\">public @interface Repeatable &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Indicates the &lt;em&gt;containing annotation type&lt;/em&gt; for the</span><br><span class=\"line\">     * repeatable annotation type.</span><br><span class=\"line\">     * @return the containing annotation type</span><br><span class=\"line\">     */</span><br><span class=\"line\">    Class&lt;? extends Annotation&gt; value();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>@Repeatable</strong> since Java 1.8 作用是使注解的值可以同时取多个</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface Persons &#123;</span><br><span class=\"line\">    Person[]  value();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Repeatable(Persons.class)</span><br><span class=\"line\">@interface Person&#123;</span><br><span class=\"line\">    String role default &quot;&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Person(role=&quot;artist&quot;)</span><br><span class=\"line\">@Person(role=&quot;coder&quot;)</span><br><span class=\"line\">@Person(role=&quot;PM&quot;)</span><br><span class=\"line\">public class SuperMan&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>@Repeatable(Persons.class)</code>中<code>Persons.class</code>相当于一个<strong>容器注解</strong>，即存放其它注解的地方。而<code>Persons</code>中又有一个<code>value</code>属性</p>\n<p>相当于Persons是一张总的标签，上面贴<code>artist</code> <code>coder</code> <code>PM</code>等同类型但内容不一样的标签</p>\n<h2 id=\"Annotations-applied-to-Java-code\"><a href=\"#Annotations-applied-to-Java-code\" class=\"headerlink\" title=\"Annotations applied to Java code\"></a>Annotations applied to Java code</h2><p><strong>内置注解</strong></p>\n<h3 id=\"Override\"><a href=\"#Override\" class=\"headerlink\" title=\"@Override\"></a>@Override</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(ElementType.METHOD)</span><br><span class=\"line\">@Retention(RetentionPolicy.SOURCE)</span><br><span class=\"line\">public @interface Override &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>@Override</strong>用于标明此方法覆盖了父类的方法。</p>\n<p>可适用元素为方法，仅仅保留在Java源文件中。</p>\n<h3 id=\"Deprecated\"><a href=\"#Deprecated\" class=\"headerlink\" title=\"@Deprecated\"></a>@Deprecated</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Documented</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span><br><span class=\"line\">public @interface Deprecated &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>@Deprecated</strong>用于标明已经过时的方法或者类。</p>\n<p>可适用于除注解类型声明之外的所有元素，保留时长为运行时JVM</p>\n<h3 id=\"SuppressWarnnings\"><a href=\"#SuppressWarnnings\" class=\"headerlink\" title=\"@SuppressWarnnings\"></a>@SuppressWarnnings</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class=\"line\">@Retention(RetentionPolicy.SOURCE)</span><br><span class=\"line\">public @interface SuppressWarnings &#123;</span><br><span class=\"line\">    String[] value();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>@SuppressWarnnings</strong>用于有选择的关闭编译器对类、方法、成员变量、变量初始化的警告。</p>\n<p>可适合用于除注解类型声明和包名之外的所有元素，仅仅保留在java源文件中。</p>\n<p>内部String数组主要接收值</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>deprecation</td>\n<td>使用了过时的类或方法时的警告</td>\n</tr>\n<tr>\n<td>unchecked</td>\n<td>执行了未检查的转换时的警告</td>\n</tr>\n<tr>\n<td>fallthrough</td>\n<td>当Switch程序块进入进入下一个case而没有Break时的警告</td>\n</tr>\n<tr>\n<td>path</td>\n<td>在类路径、源文件路径等有不存在路径时的警告</td>\n</tr>\n<tr>\n<td>serial</td>\n<td>当可序列化的类缺少serialVersionUID定义时的警告</td>\n</tr>\n<tr>\n<td>finally</td>\n<td>任意finally子句不能正常完成时的警告</td>\n</tr>\n<tr>\n<td>all</td>\n<td>以上所有情况的警告</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"SafeVarargs\"><a href=\"#SafeVarargs\" class=\"headerlink\" title=\"@SafeVarargs\"></a>@SafeVarargs</h3><p><strong>@SafeVarargs</strong> since Java1.7 参数安全类型注解。目的是处理可变长参数中的泛型 此注解告诉编译器：在可变参数中的泛型是类型安全的</p>\n<p>因为泛型的数据类型是运行时才确定的，因此把泛型存储到数组中时，编译器在编译阶段无法检查数据类型是否匹配，会给出警告信息：存在可能的”堆污染“（Heap Pollution） 如果泛型的真实数据类型无法和参数数组的类型匹配 会导致ClassCastException异常 因此在可变长参数中使用泛型时，编译器都会给出警告信息</p>\n<h3 id=\"FunctionalInterface\"><a href=\"#FunctionalInterface\" class=\"headerlink\" title=\"@FunctionalInterface\"></a>@FunctionalInterface</h3><p><strong>@FunctionalInterface</strong> since Java1.8 函数式接口注解。函数式接口就是一个具有一个方法的普通接口。</p>\n<p>线程开发中常用的Runnable就是典型的函数式接口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FunctionalInterface</span><br><span class=\"line\">public interface Runnable &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span><br><span class=\"line\">     * to create a thread, starting the thread causes the object&apos;s</span><br><span class=\"line\">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span><br><span class=\"line\">     * thread.</span><br><span class=\"line\">     * &lt;p&gt;</span><br><span class=\"line\">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span><br><span class=\"line\">     * take any action whatsoever.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @see     java.lang.Thread#run()</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public abstract void run();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数式接口标记的作用是可以很容易转换为Lambda表达式</p>\n<h3 id=\"comparison\"><a href=\"#comparison\" class=\"headerlink\" title=\"comparison\"></a>comparison</h3><table>\n<thead>\n<tr>\n<th>内建注解</th>\n<th>Target</th>\n<th>Retention</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Override</td>\n<td>METHOD</td>\n<td>SOURCE</td>\n</tr>\n<tr>\n<td>SuppressWarnings</td>\n<td>除ANNOTATION_TYPE和PACKAGE外的所有</td>\n<td>SOURCE</td>\n</tr>\n<tr>\n<td>Deprecated</td>\n<td>除ANNOTATION_TYPE外的所有</td>\n<td>RUNTIME</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><p><strong>example</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Documented</span><br><span class=\"line\">@Target(ElementType.METHOD)</span><br><span class=\"line\">@Inherited</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">public @interface TestAnnotation&#123;</span><br><span class=\"line\">    String username();</span><br><span class=\"line\">    String password()；</span><br><span class=\"line\">    int id() default 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>规则</strong></p>\n<ol>\n<li>注解方法不带参数</li>\n<li>注解方法返回值类型：基本类型、String、Enums、Annotation以及其数组类型</li>\n<li>注解方法可有默认值</li>\n</ol>\n<p><strong>注解的属性</strong></p>\n<p>注解的属性也叫成员变量。注解只有成员变量，没有方法。无形参。</p>\n<p>在注解中定义属性时它的类型必须是 8 种基本数据类型外加 类、接口、注解及它们的数组。</p>\n<p><code>TestAnnotation</code>这个注解中拥有<code>username</code>  <code>password</code>   <code>id</code> 三个属性，在使用时则需要对其进行赋值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@TestAnnotation(username=&quot;a&quot;,password=&quot;aaaaaa&quot;,id=1)</span><br><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>若TestAnnotation注解只有一个属性，则可不写成员变量名，直接赋值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@TestAnnotation(1)</span><br><span class=\"line\">public class Test&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Theory\"><a href=\"#Theory\" class=\"headerlink\" title=\"Theory\"></a>Theory</h2><p><code>Annotation</code>其实是一种接口。Java所有注解都继承了<code>Annotation</code>接口。通过Java的<strong>反射</strong>机制相关的API来访问Annotation信息。反射类位于包java.lang.reflect，其中有一个接口<code>AnnotatedElement</code></p>\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>方法</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>T</td>\n<td>getAnnotation(Class annotationClass)</td>\n<td>当存在该元素的指定类型注解，则返回相应注释，否则返回null</td>\n</tr>\n<tr>\n<td>Annotation[]</td>\n<td>getAnnotations()</td>\n<td>返回此元素上存在的所有注解</td>\n</tr>\n<tr>\n<td>Annotation[]</td>\n<td>getDeclaredAnnotations()</td>\n<td>返回直接存在于此元素上的所有注解。</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</td>\n<td>当存在该元素的指定类型注解，则返回true，否则返回false</td>\n</tr>\n</tbody>\n</table>\n<p>首先通过<code>Class</code>对象的<code>isAnnotationPresent()</code>判断它是否应用了某个注解，然后通过<code>getAnnotation()</code>来获取<code>Annotation</code>对象 或者是通过<code>getAnnotations()</code>方法。前者返回指定类型的注解 后者返回注解到这个元素上的所有注解。如果获取到的<code>Annotation</code>不为null，则就可以调用它们的属性方法了。</p>\n<p><strong>一个注解要在运行时被成功提取，那么必须要@Retention(RetentionPolicy.RUNTIME)</strong></p>\n<p>ps：因为注解的提取需要借助于Java反射技术 而反射比较慢 因此使用注解时需要考虑时间成本</p>\n<h2 id=\"Advantage\"><a href=\"#Advantage\" class=\"headerlink\" title=\"Advantage\"></a>Advantage</h2><ul>\n<li>提供信息给编译器： 编译器可以利用注解来探测错误和警告信息</li>\n<li>编译阶段时的处理： 软件工具可以用来利用注解信息来生成代码、Html文档或者做其它相应处理</li>\n<li>运行时的处理： 某些注解可以在程序运行的时候接受代码的提取</li>\n</ul>\n<p>当开发者使用了<code>Annotation</code> 修饰了类、方法、Field 等成员之后，这些 <code>Annotation</code>不会自己生效，必须由开发者提供相应的代码来提取并处理<code>Annotation</code>信息。</p>\n<p>​        Annotation不影响程序代码的执行，无论增加、删除，代码都始终如一的执行。如果希望让程序中的Annotation在运行时起一定的作用，只有通过某种配套工具对Annotation中的信息进行访问和处理。<strong>jdk7之前访问和处理Annotation的工具统称APT（Annotation Processing Tool)(jdk7后就被废除了），jdk7及之后采用了JSR 269 API。相关原因官方说明   、 原因</strong></p>\n<h1 id=\"Android-Annotation\"><a href=\"#Android-Annotation\" class=\"headerlink\" title=\"Android Annotation\"></a>Android Annotation</h1><h2 id=\"Android-Support-Library\"><a href=\"#Android-Support-Library\" class=\"headerlink\" title=\"Android Support Library\"></a>Android Support Library</h2><p>Android Support Library 提供了很多实用注解。</p>\n<h2 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples\"></a>Examples</h2><p> 实例化控件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bind(R.id.btn)</span><br><span class=\"line\">Button mBtn;</span><br></pre></td></tr></table></figure>\n<p>设置控件点击事件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Click(R.id.btn)</span><br><span class=\"line\">void btnClick()&#123;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在Android项目中使用Annotation 减少代码量 使代码更优雅</p>\n<p>但是缺点就是反射会降低程序的运行速度 长期的话难以维护</p>\n<h2 id=\"How-to-write-an-annotation-processor\"><a href=\"#How-to-write-an-annotation-processor\" class=\"headerlink\" title=\"How to write an annotation processor\"></a>How to write an annotation processor</h2><p><a href=\"http://hannesdorfmann.com/annotation-processing/annotationprocessing101\" target=\"_blank\" rel=\"noopener\">ANNOTATION PROCESSING 101</a></p>\n<p><a href=\"https://stackoverflow.com/questions/8587096/how-do-you-debug-java-annotation-processors-using-intellij\" target=\"_blank\" rel=\"noopener\">how do you debug java annotation processors using intellij?</a></p>\n<p>参考链接：</p>\n<p><a href=\"http://gityuan.com/2016/01/23/java-annotation/\" target=\"_blank\" rel=\"noopener\">Java注解(Annotation)</a></p>\n<p><a href=\"https://blog.csdn.net/briblue/article/details/73824058\" target=\"_blank\" rel=\"noopener\">秒懂，Java 注解 （Annotation）你可以这样学</a></p>\n<p><a href=\"https://www.cnblogs.com/skywang12345/p/3344137.html\" target=\"_blank\" rel=\"noopener\">Java Annotation认知</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650242853&amp;idx=1&amp;sn=f0df61f9e307d07f858a9aee22f3a9a0&amp;chksm=88638e4abf14075c3400d6b6bbab09b32b4653c33a99a3d24fa90b9dd9b4e609ad8c8ebe9cff&amp;scene=0&amp;key=d5c605889f4cfafbfed3da2c1c77c35cce5b97907012d464b414608509459616994c34d88859677481cc25bdeba10f02203717d2cb42c9d423009360789b9d6b4b8eda40713e17debb8fdd46b239f56e&amp;ascene=0&amp;uin=Nzc4NTg0MjE2&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.12.6+build(16G1212\" target=\"_blank\" rel=\"noopener\">在Android中优雅地使用注解</a>&amp;version=12020010&amp;nettype=WIFI&amp;lang=zh_CN&amp;fontScale=100&amp;pass_ticket=grZR6c3Qo%2BbQty7OQa%2FDyfqhSyTUxTjN4sW4kq05WQIG2zJ67%2BS6vKLbuh2mWv24)</p>\n","next":{"title":"Hello World","slug":"hello-world"},"link":"http://yoursite.com/post/Annotation"}